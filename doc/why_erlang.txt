(utf-8)

* XP et programmation fonctionnelle

La programmation fonctionnelle (au sens Haskell, Erlang...) présente
plusieurs caractéristiques la rendant très adaptée au TDD.

Attention:

- XP est applicable et utile quel que soit le langage utilise.
- le choix du langage dépend de nombreux facteurs (humains, domaine métier, code existant...)
- quand c'est possible, choisir un langage puissant et adapte au mode de travail d'XP peut démultiplier les avantages.


** Contenu

** Introduction aux langages fonctionnels

Les langages fonctionnels utilisent les fonctions plutôt que les
objets ou procédures comme briques de base pour la construction de
programmes.

FunctionalProgramming is when functions, not objects or procedures,
are the fundamental building blocks of a program. Functions in this
sense, not to be confused with CeeLanguage functions which are just
procedures, are analogous to mathematical equations: they declare a
relationship between two or more entities.

FunctionalProgramming, however, is not about mathematics but about
abstraction and reducing complexity: as such, it provides a powerful
paradigm in which to tackle complex, real-world programming tasks.

FunctionalProgrammingLanguages, which support this style of
programming, provide at least some of the following features:

- fonde sur l'evaluation d'expressions
- il n'y a que des valeurs, on ne gere pas la memoire
- Les fonctions sont des citoyens de premiere classe
- Fonctions d'ordre superieur
- Clôtures lexicales
- Programmation par cas ("pattern matching")
- Single Assignment
- List Comprehensions
- Gestion automatique de la memoire (ramasse-miette)
- Recursive style with tail call optimization
- Typage dynamique (ou inférence de type)

Ces caractéristiques visent a éliminer des causes fréquentes de
défauts de programmation et favoriser des programmes:

- courts et concis
- expressifs

An important part of (pure) FunctionalProgramming philosophy is
ReferentialTransparency, which requires writing SideEffectFree?
functions. In order to encourage this, variables are SingleAssignment,
or immutable: once they are initialized, their value cannot be
changed. Arguments to functions may only be passed by value, and
rather than modify arguments, functions must return new variables.

This alone has several implications on the style of programming
(compiler implementation and performance aspects are discussed later):

- Since functions cannot modify arguments, they need to be able to
  return more than one piece of information: therefore tuples and
  lists are widely used, and may be created on the fly in most
  FunctionalProgrammingLanguages.
- Since variables, even within functions, are immutable, writing loops
  using counters is impossible or at best unwieldy: the dominant style
  of algorithm is therefore recursive.
- Since functions cannot modify variables, they cannot store state
  between successive calls. Thus data and functions are kept
  completely separate, which is the opposite philosophy to
  ObjectOriented encapsulation.
- There may be a need for a data structure to represent the global
  state and top-level functions that operate on the global state. Most
  other functions only operate on a small part of the data, so the
  top-level functions extract pieces of the global state, pass them to
  lower-level functions, and construct a new global state using the
  results. (Incidentally, this makes it trivial to instantiate
  multiple copies of the entire application. For example, maintain a
  copy of the entire program state as it existed five minutes ago, and
  revert to it if there is an error.)
- The emphasis is on writing pure, generic functions which could work
  in any environment, and choosing actual program behaviour at the top
  of the call hierarchy. This is in contrast to ObjectOriented
  programming which encourages pushing behaviour into class methods
  and making decisions low down by overriding them in
  subclasses. (Document example moved to FunctionalModeling).

*  Survol du langage Erlang

Erlang est un langage développé et supporte par Ericsson:

- fonctionnel strict
- dynamiquement type
- programmation par cas
- valeurs immuables
- programmation concurrente (parallèle) a base de processus
  séquentiels communicants (??? terme français???)

Erlang is compiled to bytecode which runs in a VirtualMachine. It
comes complete with development tools (compiler, debugger, profiler),
libraries and applications including the MnesiaDatabase, an HTTP
server and a CORBA ORB.

Erlang is developed and supported by the Ericsson ComputerScience lab,
who has distributed it freely under an OpenSource license since 1998.

<SIMPLIFIER>
On the other hand, Erlang offers ''processes'', which are like threads
except that they are completely isolated from each other and may only
communicate by sending and receiving asynchronous messages. These
Erlang processes are ideal to represent physical models, and in many
ways satisfy the NygaardClassification better than most traditional
ObjectOriented languages. These concurrent processes are polymorphic,
in that any process which responds to a set of messages (an alphabet,
in CSP parlance), may be transparently substituted for
another. Processes also have an identity (a unique, unforgeable
process id). Code, in the form of functions, may easily be reused by
different processes.

Erlang also offers ''behaviors'', which are similar to Java
interfaces: a module conforms to a behavior if it offers a set of
functions.

So Erlang in fact offers considerable support for modeling the code
as objects. However, Erlang developers tend to model as processes only
objects that have behavior (and possibly state), unlike
SmalltalkLanguage or JavaLanguage developers who must model everything
as one. In particular, Erlang data types are not objects.
</SIMPLIFIER>

** Testabilité

- Concision et expressivité des tests
- Lambda, the ultimate mock

- testabilité des programmes multi-"thread"
Expliquer que le code multithread ne PEUT PAS être testé, même si on peut limiter les dégâts
(lister les outils, techniques... connues)
Evoquer aussi les faiblesses conceptuelles? (anti encapsulation, OCP, YAGNI)

Expliquer fonctionnement erlang
Démontrer sa testabilité
Exemple (philosophes? sudoku?)

** Symbiose entre TDD et pattern matching
 cf fibonacci.erl : 
    Lancer Erlang
    lancer testing_server:start(Dir,Notification,[]). sur le répertoire contenant le code de la présentation.
    Ecrire le test fibo(0)
    .....

    --> Les clauses initiales ( fib(0) et fib(1) ne sont pas suprimées et la transition vers le générique est naturel contrairement à l'exemple de Java)
    --> ATTENTION Le code n'est pas récursif terminal



** Abstraction, expressivite, DSL

Expressivité:
  concision (typage dynamique, compréhensions, )
  clarté (referential transparency - pas d'effets de bord)
  pattern matching
  
Expliquer que le mécanisme d'abstraction (équivalent a l'héritage) est la fonction d'ordre superieur.
EXEMPLE
Avantages ou seulement "aussi bien"?

DSL:

Externes: fichier de config en langage natif
Internes: pseudo langage spécifique a un besoin, mais qui est en fait code en Erlang...
Exemple: parser combinators? tests de recette xpdojo ? 



  

** Tableau comparatif des langages fonctionnels p/r a XP



A FAIRE
Trouver des exemples de code et montrer leur conception via TDD
Trouver des façons de faire participer l'auditoire
  - sondage a main levée (qui connaît un langage fonctionnel?)
  - après un ou deux exemples (avec TDD ping pong) inviter quelqu'un a
  essayer l'exemple suivant?

Vérifier qu'on satisfait les remarques et questions ci-dessous.
Vérifier que ça tient en 90 minutes.

-module(fibonacci).
-compile(export_all).

fibonacci(0) ->
    0;
fibonacci(1) ->
    1;
fibonacci(N) ->
    fibonacci(N-1)+fibonacci(N-2).
      
-module(fibonacci_ut).
-compile(export_all).

fibonacci_test() ->
    0 = fibonacci:fibonacci(0),
    1 = fibonacci:fibonacci(1),
    1 = fibonacci:fibonacci(2).


    
