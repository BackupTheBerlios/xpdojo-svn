-*- mode: text; fill-column: 55 -*-
(utf-8)

* XP et programmation fonctionnelle

La programmation fonctionnelle (au sens Haskell, Erlang...) présente
plusieurs caractéristiques la rendant très adaptée au TDD.

Attention:

- XP est applicable et utile quel que soit le langage utilise.
- le choix du langage dépend de nombreux facteurs (humains, domaine métier, code existant...)
- quand c'est possible, choisir un langage puissant et adapte au mode de travail d'XP peut démultiplier les avantages.


** Contenu

** Introduction aux langages fonctionnels

Les langages fonctionnels utilisent les fonctions plutôt que les
objets ou procédures comme briques de base pour la construction de
programmes. Il faut prendre le terme "fonction" dans le
mathématique du terme. Une fonction établie une
relation entre 2 ou plusieurs entités.
La programmation fonctionnelle ne concerne pas les
mathématiques mais tente de fournir des moyens de
réduire la complexité et d'offir un nouveau niveau
d'abstraction.
Les langages fonctionnels qui supporte ce gente de
programmation fournissent au moins un sous ensemble des
fonctionnalités suivante:


- fonde sur l'evaluation d'expressions
- il n'y a que des valeurs, on ne gere pas la memoire
- Les fonctions sont des citoyens de premiere classe
- Fonctions d'ordre superieur
- Clôtures lexicales
- Programmation par cas ("pattern matching")
- Single Assignment
- List Comprehensions
- Gestion automatique de la memoire (ramasse-miette)
- Recursive style with tail call optimization
- Typage dynamique (ou inférence de type)

Ces caractéristiques visent a éliminer des causes fréquentes de
défauts de programmation et favoriser des programmes:

- courts et concis
- expressifs


Une part importante de la philosophie de la
programmation fonctionnelle repose sur
ReferentialTransparency, qui nécessite d'écrire des
fonctions sans effet de bords. Pour faciliter cela, les
variables ne sont assignables qu'une fois ou
invariante: une fois initialisées, leur valeur ne peut
pas être changée. Les arguments des fonctions sont
passés par valeur, et au lieu de modifier un paramétre,
les fonctions vont retourner des nouvelles variables.
Le simple fait que les variables sont invariantes
influt le style de programmation:
- Comme les fonctions ne peuvent pas modifier les
paramêtres, elles doivent pouvoir retourner 'plusieurs
données': C'est pour cela que les tuples et les listes
sont largement employés dans les langages fonctionnels.
- Comme les variables sont invariante, l'écriture de
boucle à l'aide de compteur est impossible: La
programmation récursive est très largement majoritaire.
- Comme les fonctions ne peuvent pas modifier les
variables, elles ne peuvent pas 'stocker' d'état entre
plusieurs appels succéssifs. Il y a donc, contrairement
à la programmation orienté objet, une totale séparation
entre les données et les traitements.

- Le besoin d'avoir une structure de données globale
  pour représenter l'état global de l'application peut
  exister. Dans ce cas, seul une fonction de haut
  niveau va manipuler cette structure et extraire une
  partie de la structure pour l'injecter dans des
  fonctions plus sépcifique. Le résultat des fonctions
  spécifiques sera à son tour injecté dans l'état
  global de l'application. (L'état de l'application
  étant dans une seule structure, il est facile d'en
  instancier plusieurs instances. Ainsi, on peut
  maintenir une copie de l'état de l'application tel
  qu'il était avant le début d'un traitement et faire
  "un rollback" en cas d'échec.
- La programmation fonctionnelle nous améne à écrire
  des fonctions 'pure', générriques, qui peuvent
  fonctionner dans tous les environnements. Le
  comportement global de l'application sera défini en
  haut de la pile des appels. Ceci contraste avec la
  programmation objet qui encourage à mettre le
  comportement dans des méthodes de classes et à le
  surcharger afin de faire des choix.

*  Survol du langage Erlang

Erlang est un langage développé et supporte par Ericsson:

- fonctionnel strict
- dynamiquement type
- programmation par cas
- valeurs immuables
- programmation concurrente (parallèle) a base de processus
  séquentiels communicants (??? terme français???)

Erlang est compilé en bytecode qui tourne sur une machine virtuelle. Erlang vient avec un 'environnement de dév' complet (compilateur, debugger, profiler), des librairies et diverses applications incluant Mnesia (base de données répartie, un serveur HTTP, un ORB CORBA).

Erlang est développé et supporté par Ericsson ComputerScience lab et est distribué gratuitement sous une licence OpenSource depuis 1998.

Le langage Erlang inclue 'nativement' la notion de 'process'. Les 'process' s'apparentent aux threads dans la mesure où ils permettent dans réaliser des traitements en parrellele. Les 'process' erlang, grâce aux propriétés des langages fonctionnels, sont totalement isolé les uns des autres et peuvent uniquement communiquer entre eux que par l'intermédiaire de messages asynchrones. Un process répondant uniquement aux 'excitations' d'un ensemble de messages, ils sont polymorphiques et peuvent être substitués par un nouveau de manière totalement transparent. L'unité de code étant la fonction, different process peuvent partager  très facilement différent 'set' de fonctions.

Erlang offre également des extensions offrant des facilités de programmation et de conception d'application client/serveur. L'une de ces extensions se nomment 'behavior'. Ils sont similaires aux interfaces Java, un module erlang ayant tel 'behavior' va exposer un set de fonction.
Erlang peut modéliser le code comme des objets. Les développeur Erlang vont créer des process pour les objects qui ont un behavior (et/ou état), alors que les langage objet, vont tout modéliser avec des objets.


** Robustesse et exactitude

Ce qu'on demande tous à un programme informatique c'est
qu'il soit prédictible et qu'il offre à son utilisateur
une durée de vie entre 2 plantages suffissement
important pour ne pas le dégouter.
*** Pourquoi les programmes ont des comportements bizares,
certains les appeleront des "features cachées" ?
La principale raison est le manque de tests unitaires
et de recette. Sans tests, les effets de bords des
évolutions sont mal maitrisés, les comportements réels
du code ont du mal à être perçus et donc l'application
'marche' par elle même. Cependant, les tests ne sont
pas suffisant pour garantir le fonctionnement de
l'application. Disons plutôt que pour garantir le
fonctionnement d'une application dans TOUS les cas de
figures il faudrait mettre en oeuvre une campagne de
tests énorme mettant en action l'ensemble du code avec
un ensemble de données d'entrée exhaustif (ou proche de
l'exhaustivité). L'expression du code 'sous forme
mathématique' petmet de définir aisément l'ensemble des
valeurs d'entrée d'une fonction, Erlang faisant le
reste en remontant des erreurs si une fonction est
appelée avec des valeurs hors plage. Voila pour la
robustesse. L'exactitude des programmes, leur
prédictibilité, est favorisé par dans les langages
fonctionels grâce à la non propagation des effets de
bords et de l'indépendance des fonctions les unes par
rapport aux autres. Les fonctions, par nature ne font
que retourner un résultat. Et ce résultat est, de
surcroit, compris dans un intervalle connu et bien
défini. Il est donc beaucoup plus aisé d'écrire des
jeux de tests complets décrivant explicitement
l'ensemble des cas d'utilisation de l'application.

** Testabilité

- Concision et expressivité des tests
- Lambda, the ultimate mock


- testabilité des programmes multi-"thread"
Expliquer que le code multithread ne PEUT PAS être testé, même si on peut limiter les dégâts
(lister les outils, techniques... connues)
Evoquer aussi les faiblesses conceptuelles? (anti encapsulation, OCP, YAGNI)

Expliquer fonctionnement erlang
Démontrer sa testabilité
Exemple (philosophes? sudoku?)

** Plasticité

La transparence référentielle facilite le remaniement


** Symbiose entre TDD et pattern matching
 cf fibonacci.erl : 
    Lancer Erlang
    lancer testing_server:start(Dir,Notification,[]). sur le répertoire contenant le code de la présentation.
    Ecrire le test fibo(0)
    .....

    --> Les clauses initiales ( fib(0) et fib(1) ne sont pas suprimées et la transition vers le générique est naturel contrairement à l'exemple de Java)
    --> ATTENTION Le code n'est pas récursif terminal



** Abstraction, expressivite, DSL

Expressivité:
  concision (typage dynamique, compréhensions, )
  clarté (referential transparency - pas d'effets de bord)
  pattern matching
  
Expliquer que le mécanisme d'abstraction (équivalent a l'héritage) est la fonction d'ordre superieur.
EXEMPLE
Avantages ou seulement "aussi bien"?

DSL:

Externes: fichier de config en langage natif
Internes: pseudo langage spécifique a un besoin, mais qui est en fait code en Erlang...
Exemple: parser combinators? tests de recette xpdojo ? 



  

** Tableau comparatif des langages fonctionnels p/r a XP

(indiquer typage dynamique ou statique)



A FAIRE
Trouver des exemples de code et montrer leur conception via TDD
Trouver des façons de faire participer l'auditoire
  - sondage a main levée (qui connaît un langage fonctionnel?)
  - après un ou deux exemples (avec TDD ping pong) inviter quelqu'un a
  essayer l'exemple suivant?

Vérifier qu'on satisfait les remarques et questions ci-dessous.
Vérifier que ça tient en 90 minutes.

-module(fibonacci).
-compile(export_all).

fibonacci(0) ->
    0;
fibonacci(1) ->
    1;
fibonacci(N) ->
    fibonacci(N-1)+fibonacci(N-2).
      
-module(fibonacci_ut).
-compile(export_all).

fibonacci_test() ->
    0 = fibonacci:fibonacci(0),
    1 = fibonacci:fibonacci(1),
    1 = fibonacci:fibonacci(2).

** Typage statique ou dynamique (laisser en question...)

Typage statique utile pour:
1) documenter
2) vérifier des choses à la compilation

==> devient superflu avec TDD



    
